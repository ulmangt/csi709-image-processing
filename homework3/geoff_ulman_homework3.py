import os, sys, scipy, numpy, Image, sophia, color, eigenimage

def main( directory='.' ):
  evls, emgs = generateEigenImagesDirectory( directory )
  displaySubImages( emgs, evls , 8, 6 )

def generateEigenImagesDirectory( directory ):
  """Generates eigenimages from the photos in a directory."""
  l = splitImages( directory )
  return generateEigenImagesColor( l )

def generateEigenImagesColor( imageList ):
  """Given a collection of images generated by splitImages(), returns two
     tuples containing eigen values and eigen images for each of the
     three channels: YUV."""
  emgs1, evls1 = eigenimage.EigenImages( numpy.array( imageList[0] ) )
  emgs2, evls2 = eigenimage.EigenImages( numpy.array( imageList[1] ) )
  emgs3, evls3 = eigenimage.EigenImages( numpy.array( imageList[2] ) )

  return (evls1, evls2, evls3), (emgs1, emgs2, emgs3 );

def splitImages( directory, n=64, m=64 ):
  """Given a directory containing images, returns a list of smaller n by m sub-images"""
  
  # allocate lists for storing the sub images (split into three color channels)
  l1 = []
  l2 = []
  l3 = []

  # iterate through the files in the directory
  for f in os.listdir( directory ):
    print "Processing: ", f

    # load the image in a try/except block to avoid
    # failing if there are non-image files in the directory
    try:
      image = Image.open( os.path.join( directory, f ) )
    except IOError:
      print "Trouble opening image: ", f

    l = splitImage( image, n, m )
    l1.extend( l[0] )
    l2.extend( l[1] )
    l3.extend( l[2] )

  return ( l1, l2, l3 )

def splitImage( image, n=64, m=64 ):
  """
Given a single image, splits the image into smaller n by m non-overlapping
sub-images and returns a list of the sub-images. If the size of the input
image is not an even multiple of n or m, some parts of the image will not
be used."""

  # create a list for the sub-images
  l1 = []
  l2 = []
  l3 = []

  # convert the image to matricies
  r,g,b = sophia.Image2Cube( image )

  # convert the r, g, b matrices to y, u, v colorspace
  y,u,v = color.RGB2YUV( r, g, b )

  # get the x and y size of the image
  sizeX = image.size[0]
  sizeY = image.size[1]

  # x and y pixel index counters
  xi = 0
  yi = 0

  # generate a Kaiser Mask
  # set radius2 such that no pixels in the n by m patch are completely masked
  # (this causes hard boundaries in the eigenimages)
  mask = sophia.KaiserMask( (n,m), (n/2,m/2), -20, numpy.sqrt( (n/2)**2+(m/2)**2 ) )

  # iterate over the image, cutting out n by m chunks, applying the
  # Kaiser Mask and storing the image components in the three lists
  while ( xi < sizeX - n ):
    yi = 0
    while ( yi < sizeY - m ):

      # generate sub matrix
      c1, c2, c3 = subImage( y, u, v, xi, yi, n, m )

      # apply mask
      c1 = c1 * mask
      c2 = c2 * mask
      c3 = c3 * mask

      l1.append( c1 )
      l2.append( c2 )
      l3.append( c3 )

      yi += m
    xi += n

  return ( l1, l2, l3 )

def subImage( c1, c2, c3, xi, yi, n=64, m=64 ):
  """Given three matrices c1, c2, c3 representing an image,
     selects a portion of the image starting at pixel (x,y)
     of size n by m."""
  
  s1 = c1[yi:yi+m,xi:xi+n]
  s2 = c2[yi:yi+m,xi:xi+n]
  s3 = c3[yi:yi+m,xi:xi+n]

  return ( s1, s2, s3 )

def YUV2RGB(y,u,v):
  """Simple routine to convert from yuv color space to rgb"""

  r = 1.0*y + 0.0*u + 1.13983*v
  g = 1.0*y - 0.39465*u + -0.58060*v
  b = 1.0*y + 2.03211*u + 0.0*v

  return r,g,b

def displaySubImages( emgs, evls, row, col, n=64, m=64 ):
  """Given the output of generateEigenImagesColor(), constructs
     a grid of eigenimages with the given number of rows
     and columns."""

  # allocate numpy matrix for the three color components of the
  # grid of eigenimages
  c1 = numpy.zeros( ( row * n , col * m ) );
  c2 = numpy.zeros( ( row * n , col * m ) );
  c3 = numpy.zeros( ( row * n , col * m ) );

  # iterate over the grid
  index = 0
  for r in range( row ):
    for c in range( col ):

      # I experimented with various scalings of the eigenimages
      # based on their corresponding eigenvalues, but none worked well
      #ya = emgs[0][index] * numpy.sqrt( evls[0][index] )
      #ua = emgs[1][index] * numpy.sqrt( evls[1][index] )
      #va = emgs[2][index] * numpy.sqrt( evls[2][index] )

      # unpack the eigenimage
      ya = emgs[0][index]
      ua = emgs[1][index]
      va = emgs[2][index]

      # convert to rgb colorspace
      ra,ga,ba = YUV2RGB( ya, ua, va )

      # place the n by m eigenimage into the appropriate location
      # in the larger grid of eigenimages
      c1[r*n:(r+1)*n,c*m:(c+1)*m] = normalize( ra )
      c2[r*n:(r+1)*n,c*m:(c+1)*m] = normalize( ga )
      c3[r*n:(r+1)*n,c*m:(c+1)*m] = normalize( ba )

      index += 1

  # create and display a combined image
  imr = sophia.a2if( c1 )
  img = sophia.a2if( c2 )
  imb = sophia.a2if( c3 )

  Image.merge( 'RGB', ( imr, img,  imb ) ).show()


def normalize( indata ):
  """copied from Sophia, normalizes a matrix with values from
     0 to 255 but returns another matrix instead of an image"""

  mn = indata.min()
  a = indata - mn
  mx = a.max()
  a = a*255./mx
  return a;


def displaySubImage( l, i ):
  """
A debugging function. Given a list of sub-images produced by splitImage and
an index into the list, displays the sub-image"""
  r, g, b = YUV2RGB( l[0][i], l[1][i], l[2][i] )
  Image.merge( 'RGB', ( sophia.a2i(r), sophia.a2i(g), sophia.a2i(b) ) ).show()

# I was initially worried that the ordering of the eigenvalues was
# affecting the results, so I tried a number of routines to sort
# the eigenvalues/eigenimages in various ways. However, none had
# significant effect on the results.

def sortEigenImages( evls, emgs ):
  """Given tuples of eigen values and eigen images returned by
     generateEigenImagesColor(), sorts the eigenimages by descending
     eigenvalue. The eigenimages for the three channels are sorted
     together, acording to the maximum of their associated eigenvalues."""
  evls1, evls2, evls3 = evls
  emgs1, emgs2, emgs3 = emgs

  evlsmax = max( list(evls1), list(evls2), list(evls3) )
  sorted_l = sorted( zip( evlsmax, evls1, evls2, evls3, emgs1, emgs2, emgs3 ) )
  sorted_l.reverse( )
  evlsmax, evls1, evls2, evls3, emgs1, emgs2, emgs3 = zip( *sorted_l )

  return (evls1, evls2, evls3), (emgs1, emgs2, emgs3 )

def sortEigenImagesSeparate( evls, emgs ):
  """Given tuples of eigen values and eigen images returned by
     generateEigenImagesColor(), sorts the eigenimages by descending
     eigenvalue. The eigenimages for the three channels are
     sorted independently."""

  sevls1, semgs1 = sortEigenImagesSingle( evls[0], emgs[0] )
  sevls2, semgs2 = sortEigenImagesSingle( evls[1], emgs[1] )
  sevls3, semgs3 = sortEigenImagesSingle( evls[2], emgs[2] )

  return (sevls1, sevls2, sevls3), (semgs1, semgs2, semgs3 )

def sortEigenImagesSingle( evls, emgs ):
  """A helper routine for sortEigenImagesSeparate( ). Sorts the
     eigenimages of a single color channel by eigenvalue."""

  sorted_l = sorted( zip( evls, emgs ) )
  sorted_l.reverse()
  sorted_evls, sorted_emgs = zip( *sorted_l )

  return sorted_evls, sorted_emgs;

if __name__ == "__main__":
  main() 

